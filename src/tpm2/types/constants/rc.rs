//! TPM Library Part 2 Chapter 6 - Constants
//!
//! Module description ... TODO

use crate::tpm2::errors;
use crate::tpm2::serialization::inout::{RwBytes, Tpm2StructIn};

use std::convert::TryFrom;
use std::{fmt,result};

#[cfg(build_rc_strings)]
use phf::{phf_map};

/// TPM_RC
#[derive(Clone, Copy, Default, Debug, Eq, Hash, PartialEq)]
#[repr(u32)]
pub enum TpmRc {
    #[default]
    Success = 0x000,
    BadTag = 0x01E,
    // TPM_RC_VER1 Section
    Ver1 = 0x100,
    // Two enum variants cannot have the same value, make Initialize
    // an impl constant (see below).
    //Initialize = (TpmRc::Ver1 as u32) + 0x000,
    Failure = (TpmRc::Ver1 as u32) + 0x001,
    Sequence = (TpmRc::Ver1 as u32) + 0x003,
    Private = (TpmRc::Ver1 as u32) + 0x00B,
    HMAC = (TpmRc::Ver1 as u32) + 0x019,
    Disabled = (TpmRc::Ver1 as u32) + 0x020,
    Exclusive = (TpmRc::Ver1 as u32) + 0x021,
    AuthType = (TpmRc::Ver1 as u32) + 0x024,
    AuthMissing = (TpmRc::Ver1 as u32) + 0x025,
    Policy = (TpmRc::Ver1 as u32) + 0x026,
    Pcr = (TpmRc::Ver1 as u32) + 0x027,
    PcrChanged = (TpmRc::Ver1 as u32) + 0x028,
    Upgrade = (TpmRc::Ver1 as u32) + 0x02D,
    TooManyContexts = (TpmRc::Ver1 as u32) + 0x02E,
    AuthUnavailable = (TpmRc::Ver1 as u32) + 0x02F,
    Reboot = (TpmRc::Ver1 as u32) + 0x030,
    Unbalanced = (TpmRc::Ver1 as u32) + 0x031,
    CommandSize = (TpmRc::Ver1 as u32) + 0x042,
    CommandCode = (TpmRc::Ver1 as u32) + 0x043,
    AuthSize = (TpmRc::Ver1 as u32) + 0x044,
    AuthContext = (TpmRc::Ver1 as u32) + 0x045,
    NvRange = (TpmRc::Ver1 as u32) + 0x046,
    NvSize = (TpmRc::Ver1 as u32) + 0x047,
    NvLocked = (TpmRc::Ver1 as u32) + 0x048,
    NvAuthorization = (TpmRc::Ver1 as u32) + 0x049,
    NvUninitialized = (TpmRc::Ver1 as u32) + 0x04A,
    NvSpace = (TpmRc::Ver1 as u32) + 0x04B,
    NvDefined = (TpmRc::Ver1 as u32) + 0x04C,
    BadContext = (TpmRc::Ver1 as u32) + 0x050,
    CpHash = (TpmRc::Ver1 as u32) + 0x051,
    Parent = (TpmRc::Ver1 as u32) + 0x052,
    NeedsTest = (TpmRc::Ver1 as u32) + 0x053,
    NoResult = (TpmRc::Ver1 as u32) + 0x054,
    Sensitive = (TpmRc::Ver1 as u32) + 0x055,
    MaxFM0 = (TpmRc::Ver1 as u32) + 0x07F,
    // TPM_RC_FMT1 Ssection
    Fmt1 = 0x080,
    Asymmetric = (TpmRc::Fmt1 as u32) + 0x001,
    Attributes = (TpmRc::Fmt1 as u32) + 0x002,
    Hash = (TpmRc::Fmt1 as u32) + 0x003,
    Value = (TpmRc::Fmt1 as u32) + 0x004,
    Hierarchy = (TpmRc::Fmt1 as u32) + 0x005,
    KeySize = (TpmRc::Fmt1 as u32) + 0x007,
    Mgf = (TpmRc::Fmt1 as u32) + 0x008,
    Mode = (TpmRc::Fmt1 as u32) + 0x009,
    Type = (TpmRc::Fmt1 as u32) + 0x00A,
    Handle = (TpmRc::Fmt1 as u32) + 0x00B,
    Kdf = (TpmRc::Fmt1 as u32) + 0x00C,
    Range = (TpmRc::Fmt1 as u32) + 0x00D,
    AuthFail = (TpmRc::Fmt1 as u32) + 0x00E,
    Nonce = (TpmRc::Fmt1 as u32) + 0x00F,
    Pp = (TpmRc::Fmt1 as u32) + 0x010,
    Scheme = (TpmRc::Fmt1 as u32) + 0x012,
    Size = (TpmRc::Fmt1 as u32) + 0x015,
    Symmetric = (TpmRc::Fmt1 as u32) + 0x016,
    Tag = (TpmRc::Fmt1 as u32) + 0x017,
    Selector = (TpmRc::Fmt1 as u32) + 0x018,
    Insufficient = (TpmRc::Fmt1 as u32) + 0x01A,
    Signature = (TpmRc::Fmt1 as u32) + 0x01B,
    Key = (TpmRc::Fmt1 as u32) + 0x01C,
    PolicyFail = (TpmRc::Fmt1 as u32) + 0x01D,
    Integrity = (TpmRc::Fmt1 as u32) + 0x01F,
    Ticket = (TpmRc::Fmt1 as u32) + 0x020,
    ReservedBits = (TpmRc::Fmt1 as u32) + 0x021,
    BadAuth = (TpmRc::Fmt1 as u32) + 0x022,
    Expired = (TpmRc::Fmt1 as u32) + 0x023,
    PolicyCc = (TpmRc::Fmt1 as u32) + 0x024,
    Binding = (TpmRc::Fmt1 as u32) + 0x025,
    Curve = (TpmRc::Fmt1 as u32) + 0x026,
    EccPoint = (TpmRc::Fmt1 as u32) + 0x027,
    // TPM_RC_WARN Section
    Warn = 0x900,
    ContextGap = (TpmRc::Warn as u32) + 0x001,
    ObjectMemory = (TpmRc::Warn as u32) + 0x002,
    SessionMemory = (TpmRc::Warn as u32) + 0x003,
    Memory = (TpmRc::Warn as u32) + 0x004,
    SessionHandles = (TpmRc::Warn as u32) + 0x005,
    ObjectHandles = (TpmRc::Warn as u32) + 0x006,
    Locality = (TpmRc::Warn as u32) + 0x007,
    Yielded = (TpmRc::Warn as u32) + 0x008,
    Canceled = (TpmRc::Warn as u32) + 0x009,
    Testing = (TpmRc::Warn as u32) + 0x00A,
    ReferenceH0 = (TpmRc::Warn as u32) + 0x010,
    ReferenceH1 = (TpmRc::Warn as u32) + 0x011,
    ReferenceH2 = (TpmRc::Warn as u32) + 0x012,
    ReferenceH3 = (TpmRc::Warn as u32) + 0x013,
    ReferenceH4 = (TpmRc::Warn as u32) + 0x014,
    ReferenceH5 = (TpmRc::Warn as u32) + 0x015,
    ReferenceH6 = (TpmRc::Warn as u32) + 0x016,
    ReferenceS0 = (TpmRc::Warn as u32) + 0x018,
    ReferenceS1 = (TpmRc::Warn as u32) + 0x019,
    ReferenceS2 = (TpmRc::Warn as u32) + 0x01A,
    ReferenceS3 = (TpmRc::Warn as u32) + 0x01B,
    ReferenceS4 = (TpmRc::Warn as u32) + 0x01C,
    ReferenceS5 = (TpmRc::Warn as u32) + 0x01D,
    ReferenceS6 = (TpmRc::Warn as u32) + 0x01E,
    NvRate = (TpmRc::Warn as u32) + 0x020,
    Lockout = (TpmRc::Warn as u32) + 0x021,
    Retry = (TpmRc::Warn as u32) + 0x022,
    NvUnavailable = (TpmRc::Warn as u32) + 0x023,
    NotUsed = (TpmRc::Warn as u32) + 0x7F,
}

impl TpmRc {
    pub const INITIALIZE: TpmRc = TpmRc::Ver1;
}

// TpmRc does not need to be marshalled out, ie. no Tpm2StructOut trait

impl Tpm2StructIn for TpmRc {
    fn unpack(
        &mut self,
        buff: &mut dyn RwBytes,
    ) -> result::Result<(), errors::DeserializationError> {
        let byte_array = <[u8; size_of!(TpmRc)]>::try_from(&buff.read_bytes(size_of!(TpmRc))[..]);
        match byte_array {
            Ok(byte_array) => {
                *self = match u32::from_be_bytes(byte_array) {
                    a if a == TpmRc::Success as u32 => Self::Success,
                    a if a == TpmRc::BadTag as u32 => Self::BadTag,
                    // TPM_RC_VER1 Section
                    a if a == TpmRc::Ver1 as u32 => Self::INITIALIZE,
                    a if a == TpmRc::Failure as u32 => Self::Failure,
                    a if a == TpmRc::Sequence as u32 => Self::Sequence,
                    a if a == TpmRc::Private as u32 => Self::Private,
                    a if a == TpmRc::HMAC as u32 => Self::HMAC,
                    a if a == TpmRc::Disabled as u32 => Self::Disabled,
                    a if a == TpmRc::Exclusive as u32 => Self::Exclusive,
                    a if a == TpmRc::AuthType as u32 => Self::AuthType,
                    a if a == TpmRc::AuthMissing as u32 => Self::AuthMissing,
                    a if a == TpmRc::Policy as u32 => Self::Policy,
                    a if a == TpmRc::Pcr as u32 => Self::Pcr,
                    a if a == TpmRc::PcrChanged as u32 => Self::PcrChanged,
                    a if a == TpmRc::Upgrade as u32 => Self::Upgrade,
                    a if a == TpmRc::TooManyContexts as u32 => Self::TooManyContexts,
                    a if a == TpmRc::AuthUnavailable as u32 => Self::AuthUnavailable,
                    a if a == TpmRc::Reboot as u32 => Self::Reboot,
                    a if a == TpmRc::Unbalanced as u32 => Self::Unbalanced,
                    a if a == TpmRc::CommandSize as u32 => Self::CommandSize,
                    a if a == TpmRc::CommandCode as u32 => Self::CommandCode,
                    a if a == TpmRc::AuthSize as u32 => Self::AuthSize,
                    a if a == TpmRc::AuthContext as u32 => Self::AuthContext,
                    a if a == TpmRc::NvRange as u32 => Self::NvRange,
                    a if a == TpmRc::NvSize as u32 => Self::NvSize,
                    a if a == TpmRc::NvLocked as u32 => Self::NvLocked,
                    a if a == TpmRc::NvAuthorization as u32 => Self::NvAuthorization,
                    a if a == TpmRc::NvUninitialized as u32 => Self::NvUninitialized,
                    a if a == TpmRc::NvSpace as u32 => Self::NvSpace,
                    a if a == TpmRc::NvDefined as u32 => Self::NvDefined,
                    a if a == TpmRc::BadContext as u32 => Self::BadContext,
                    a if a == TpmRc::CpHash as u32 => Self::CpHash,
                    a if a == TpmRc::Parent as u32 => Self::Parent,
                    a if a == TpmRc::NeedsTest as u32 => Self::NeedsTest,
                    a if a == TpmRc::NoResult as u32 => Self::NoResult,
                    a if a == TpmRc::Sensitive as u32 => Self::Sensitive,
                    a if a == TpmRc::MaxFM0 as u32 => Self::MaxFM0,
                    //TPM_RC_FMT1 Ssection
                    a if a == TpmRc::Fmt1 as u32 => Self::Fmt1,
                    a if a == TpmRc::Asymmetric as u32 => Self::Asymmetric,
                    a if a == TpmRc::Attributes as u32 => Self::Attributes,
                    a if a == TpmRc::Hash as u32 => Self::Hash,
                    a if a == TpmRc::Value as u32 => Self::Value,
                    a if a == TpmRc::Hierarchy as u32 => Self::Hierarchy,
                    a if a == TpmRc::KeySize as u32 => Self::KeySize,
                    a if a == TpmRc::Mgf as u32 => Self::Mgf,
                    a if a == TpmRc::Mode as u32 => Self::Mode,
                    a if a == TpmRc::Type as u32 => Self::Type,
                    a if a == TpmRc::Handle as u32 => Self::Handle,
                    a if a == TpmRc::Kdf as u32 => Self::Kdf,
                    a if a == TpmRc::Range as u32 => Self::Range,
                    a if a == TpmRc::AuthFail as u32 => Self::AuthFail,
                    a if a == TpmRc::Nonce as u32 => Self::Nonce,
                    a if a == TpmRc::Pp as u32 => Self::Pp,
                    a if a == TpmRc::Scheme as u32 => Self::Scheme,
                    a if a == TpmRc::Size as u32 => Self::Size,
                    a if a == TpmRc::Symmetric as u32 => Self::Symmetric,
                    a if a == TpmRc::Tag as u32 => Self::Tag,
                    a if a == TpmRc::Selector as u32 => Self::Selector,
                    a if a == TpmRc::Insufficient as u32 => Self::Insufficient,
                    a if a == TpmRc::Signature as u32 => Self::Signature,
                    a if a == TpmRc::Key as u32 => Self::Key,
                    a if a == TpmRc::PolicyFail as u32 => Self::PolicyFail,
                    a if a == TpmRc::Integrity as u32 => Self::Integrity,
                    a if a == TpmRc::Ticket as u32 => Self::Ticket,
                    a if a == TpmRc::ReservedBits as u32 => Self::ReservedBits,
                    a if a == TpmRc::BadAuth as u32 => Self::BadAuth,
                    a if a == TpmRc::Expired as u32 => Self::Expired,
                    a if a == TpmRc::PolicyCc as u32 => Self::PolicyCc,
                    a if a == TpmRc::Binding as u32 => Self::Binding,
                    a if a == TpmRc::Curve as u32 => Self::Curve,
                    a if a == TpmRc::EccPoint as u32 => Self::EccPoint,
                    //TPM_RC_WARN Ssection
                    a if a == TpmRc::Warn as u32 => Self::Warn,
                    a if a == TpmRc::ContextGap as u32 => Self::ContextGap,
                    a if a == TpmRc::ObjectMemory as u32 => Self::ObjectMemory,
                    a if a == TpmRc::SessionMemory as u32 => Self::SessionMemory,
                    a if a == TpmRc::Memory as u32 => Self::Memory,
                    a if a == TpmRc::SessionHandles as u32 => Self::SessionHandles,
                    a if a == TpmRc::ObjectHandles as u32 => Self::ObjectHandles,
                    a if a == TpmRc::Locality as u32 => Self::Locality,
                    a if a == TpmRc::Yielded as u32 => Self::Yielded,
                    a if a == TpmRc::Canceled as u32 => Self::Canceled,
                    a if a == TpmRc::Testing as u32 => Self::Testing,
                    a if a == TpmRc::ReferenceH0 as u32 => Self::ReferenceH0,
                    a if a == TpmRc::ReferenceH1 as u32 => Self::ReferenceH1,
                    a if a == TpmRc::ReferenceH2 as u32 => Self::ReferenceH2,
                    a if a == TpmRc::ReferenceH3 as u32 => Self::ReferenceH3,
                    a if a == TpmRc::ReferenceH4 as u32 => Self::ReferenceH4,
                    a if a == TpmRc::ReferenceH5 as u32 => Self::ReferenceH5,
                    a if a == TpmRc::ReferenceH6 as u32 => Self::ReferenceH6,
                    a if a == TpmRc::ReferenceS0 as u32 => Self::ReferenceS0,
                    a if a == TpmRc::ReferenceS1 as u32 => Self::ReferenceS1,
                    a if a == TpmRc::ReferenceS2 as u32 => Self::ReferenceS2,
                    a if a == TpmRc::ReferenceS3 as u32 => Self::ReferenceS3,
                    a if a == TpmRc::ReferenceS4 as u32 => Self::ReferenceS4,
                    a if a == TpmRc::ReferenceS5 as u32 => Self::ReferenceS5,
                    a if a == TpmRc::ReferenceS6 as u32 => Self::ReferenceS6,
                    a if a == TpmRc::NvRate as u32 => Self::NvRate,
                    a if a == TpmRc::Lockout as u32 => Self::Lockout,
                    a if a == TpmRc::Retry as u32 => Self::Retry,
                    a if a == TpmRc::NvUnavailable as u32 => Self::NvUnavailable,
                    a if a == TpmRc::NotUsed as u32 => Self::NotUsed,
                    _ => return Err(errors::DeserializationError {
                        msg: String::from("could not prepare byteArray"),
                    }),
                };
                Ok(())
            }
            Err(_) => Err(errors::DeserializationError {
                msg: String::from("could not prepare byteArray"),
            }),
        }
    }
}


#[cfg(build_rc_strings)]
static RC_CODE_STRINGS: phf::Map<&'static TpmRc, &'static str> = phf_map! {
    TpmRc::Success => "success",
    TpmRc::BadTag => "defined for compatibility with TPM 1.2",
    TpmRc::INITIALIZE => "tpm not initialized by TPM2_Startup or already initialized",
    TpmRc::Failure => "commands not being accepted because of a TPM failure",
    TpmRc::Sequence => "improper use of a sequence handle",
    TpmRc::Private => "not currently used",
    TpmRc::HMAC => "not currently used",
    TpmRc::Disabled => "the command is disabled",
    TpmRc::Exclusive => "command failed because audit sequence required exclusivity",
    TpmRc::AuthType => "authorization handle is not correct for command",
    TpmRc::AuthMissing => "command requires an authorization session for handle and it is not present.",
    TpmRc::Policy => "policy failure in math operation or an invalid authPolicy value",
    TpmRc::Pcr => "pcr check fail",
    TpmRc::PcrChanged => "pcr have changed since checked.",
    TpmRc::Upgrade => "for all commands other than TPM2FieldUpgradeData(), this code indicates that the TPM is in field upgrade mode; for TPM2_FieldUpgradeData(), this code indicates that the TPM is not in field upgrade mode",
    TpmRc::TooManyContexts => "context ID counter is at maximum.",
    TpmRc::AuthUnavailable => "authValue or authPolicy is not available for selected entity.",
    TpmRc::Reboot => "a Tpm_init and Startup(CLEAR) is required before the TPM can resume operation.",
    TpmRc::Unbalanced => "the protection algorithms (hash and symmetric) are not reasonably balanced. The digest size of the hash must be larger than the key size of the symmetric algorithm.",
    TpmRc::CommandSize => "command commandSize value is inconsistent with contents of the command buffer; either the size is not the same as the octets loaded by the hardware interface layer or the value is not large enough to hold a command header",
    TpmRc::CommandCode => "command code not supported",
    TpmRc::Authsize => "the value of authorizationSize is out of range or the number of octets in the Authorization Area is greater than required",
    TpmRc::AuthContext => "use of an authorization session with a context command or another command that cannot have an authorization session.",
    TpmRc::NvRange => "nv offset+size is out of range.",
    TpmRc::NvSize => "requested allocation size is larger than allowed.",
    TpmRc::NvLocked => "nv access locked.",
    TpmRc::NvAuthorization => "nv access authorization fails in command actions (this failure does not affect lockout.action)",
    TpmRc::NvUninitialized => "an NV Index is used before being initialized or the state saved by TPM2_Shutdown(STATE) could not be restored",
    TpmRc::NvSpace => "insufficient space for NV allocation",
    TpmRc::NvDefined => "nv index or persistent object already defined",
    TpmRc::BadContext => "context in TPM2_ContextLoad() is not valid",
    TpmRc::Cphash => "cphash value already set or not correct for use",
    TpmRc::Parent => "handle for parent is not a valid parent",
    TpmRc::NeedsTest => "some function needs testing.",
    TpmRc::NoResult => "returned when an internal function cannot process a request due to an unspecified problem. This code is usually related to invalid parameters that are not properly filtered by the input unmarshaling code.",
    TpmRc::Sensitive => "the sensitive area did not unmarshal correctly after decryption – this code is used in lieu of the other unmarshaling errors so that an attacker cannot determine where the unmarshaling error occurred",
    TpmRc::MaxFM0 => "largest version 1 code that is not a warning",
    TpmRc::Asymmetric => "asymmetric algorithm not supported or not correct",
    TpmRc::Attributes => "inconsistent attributes",
    TpmRc::Hash => "hash algorithm not supported or not appropriate",
    TpmRc::Value => "value is out of range or is not correct for the context",
    TpmRc::Hierarchy => "hierarchy is not enabled or is not correct for the use",
    TpmRc::KeySize => "key size is not supported",
    TpmRc::Mgf => "mask generation function not supported",
    TpmRc::Mode => "mode of operation not supported",
    TpmRc::Type => "the type of the value is not appropriate for the use",
    TpmRc::Handle => "the handle is not correct for the use",
    TpmRc::Kdf => "unsupported key derivation function or function not appropriate for use",
    TpmRc::Range => "value was out of allowed range.",
    TpmRc::AuthFail => "the authorization HMAC check failed and DA counter incremented",
    TpmRc::Nonce => "invalid nonce size or nonce value mismatch",
    TpmRc::Pp => "authorization requires assertion of PP",
    TpmRc::Scheme => "unsupported or incompatible scheme",
    TpmRc::Size => "structure is the wrong size",
    TpmRc::Symmetric => "unsupported symmetric algorithm or key size, or not appropriate for instance",
    TpmRc::Tag => "incorrect structure tag",
    TpmRc::Selector => "union selector is incorrect",
    TpmRc::Insufficient => "the TPM was unable to unmarshal a value because there were not enough octets in the input buffer",
    TpmRc::Signature => "the signature is not valid",
    TpmRc::Key => "key fields are not compatible with the selected use",
    TpmRc::PolicyFail => "a policy check failed",
    TpmRc::Integrity => "integrity check failed",
    TpmRc::Ticket => "invalid ticket",
    TpmRc::ReservedBits => "reserved bits not set to zero as required",
    TpmRc::BadAuth => "authorization failure without DA implications",
    TpmRc::Expired => "the policy has expired",
    TpmRc::PolicyCc => "the commandCode in the policy is not the commandCode of the command or the command code in a policy command references a command that is not implemented",
    TpmRc::Binding => "public and sensitive portions of an object are not cryptographically bound",
    TpmRc::Curve => "curve not supported",
    TpmRc::EccPoint => "point is not on the required curve.",
    TpmRc::ContextGap => "gap for context ID is too large",
    TpmRc::ObjectMemory => "out of memory for object contexts",
    TpmRc::SessionMemory => "out of memory for session contexts",
    TpmRc::Memory => "out of shared object/session memory or need space for internal operations",
    TpmRc::SessionHandles => "out of session handles – a session must be flushed before a new session may be created",
    TpmRc::ObjectHandles => "out of object handles – the handle space for objects is depleted and a reboot is required",
    TpmRc::Locality => "bad locality",
    TpmRc::Yielded => "the TPM has suspended operation on the command; forward progress was made and the command may be retried",
    TpmRc::Canceled => "the command was canceled",
    TpmRc::Testing => "tpm is performing self-tests",
    TpmRc::ReferenceH0 => "the 1st handle in the handle area references a transient object or session that is not loaded",
    TpmRc::ReferenceH1 => "the 2nd handle in the handle area references a transient object or session that is not loaded",
    TpmRc::ReferenceH2 => "the 3rd handle in the handle area references a transient object or session that is not loaded",
    TpmRc::ReferenceH3 => "the 4th handle in the handle area references a transient object or session that is not loaded",
    TpmRc::ReferenceH4 => "the 5th handle in the handle area references a transient object or session that is not loaded",
    TpmRc::ReferenceH5 => "the 6th handle in the handle area references a transient object or session that is not loaded",
    TpmRc::ReferenceH6 => "the 7th handle in the handle area references a transient object or session that is not loaded",
    TpmRc::ReferenceS0 => "the 1st authorization session handle references a session that is not loaded",
    TpmRc::ReferenceS1 => "the 2nd authorization session handle references a session that is not loaded",
    TpmRc::ReferenceS2 => "the 3rd authorization session handle references a session that is not loaded",
    TpmRc::ReferenceS3 => "the 4th authorization session handle references a session that is not loaded",
    TpmRc::ReferenceS4 => "the 5th session handle references a session that is not loaded",
    TpmRc::ReferenceS5 => "the 6th session handle references a session that is not loaded",
    TpmRc::ReferenceS6 => "the 7th authorization session handle references a session that is not loaded",
    TpmRc::NvRate => "the TPM is rate-limiting accesses to prevent wearout of NV",
    TpmRc::Lockout => "authorizations for objects subject to DA protection are not allowed at this time because the TPM is in DA lockout mode",
    TpmRc::Retry => "the TPM was not able to start the command",
    TpmRc::NvUnavailable => "the command may require writing of NV and NV is not current accessible",
    TpmRc::NotUsed => "this value is reserved and shall not be returned by the TPM",
};

impl fmt::Display for TpmRc {
    #[cfg(build_rc_strings)]
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", RC_CODE_STRINGS.get(self).cloned())
    }
    #[cfg(not(build_rc_strings))]
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:#x}", &(*self as u32))
    }
}
